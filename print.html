<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Supersim</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Supersim</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ethereum-optimism/supersim" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Supersim is a lightweight tool to simulate the Superchain (with a single L1 and multiple OP-Stack L2s).</p>
<p>Run multiple local nodes with one command, and coordinate message passing between these chains.</p>
<p>It does not require a complicated devnet setup and is run using cli commands with configuration options that fall back to sensible defaults if they are not specified. Each chain is an instance of <a href="https://book.getfoundry.sh/reference/anvil/">anvil</a>, though future versions may support other local testing tools.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li>spin up multiple anvil nodes</li>
<li>predeployed OP Stack contracts and useful mock contracts (ERC20)</li>
<li>fork multiple remote chains (fork the entire Superchain)</li>
<li>simulate L1 &lt;&gt; L2 message passing (deposits)</li>
<li>simulate L2 &lt;&gt; L2 message passing (interoperability) and auto-relayer</li>
<li>(<strong>Coming soon</strong>) Withdrawals</li>
<li>(<strong>Coming soon</strong>) ERC-4337 account abstraction services (bundlers / paymasters / wallet implementation)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="1-prerequisites-foundry"><a class="header" href="#1-prerequisites-foundry">1. Prerequisites: <code>foundry</code></a></h2>
<p><code>supersim</code> requires <code>anvil</code> to be installed.</p>
<p>Follow the guide <a href="https://book.getfoundry.sh/getting-started/installation">here</a> to install the Foundry toolchain.</p>
<h2 id="2-install-supersim"><a class="header" href="#2-install-supersim">2. Install <code>supersim</code></a></h2>
<h3 id="precompiled-binaries"><a class="header" href="#precompiled-binaries">Precompiled Binaries</a></h3>
<p>Download the executable for your platform from the <a href="https://github.com/ethereum-optimism/supersim/releases">GitHub releases page</a>.</p>
<h3 id="homebrew-os-x-linux"><a class="header" href="#homebrew-os-x-linux">Homebrew (OS X, Linux)</a></h3>
<pre><code class="language-sh">brew tap ethereum-optimism/tap
brew install supersim
</code></pre>
<h2 id="3-start-supersim-in-vanilla-mode"><a class="header" href="#3-start-supersim-in-vanilla-mode">3. Start <code>supersim</code> in vanilla mode</a></h2>
<pre><code class="language-sh">supersim
</code></pre>
<p>Vanilla mode will start 3 chains, with the OP Stack contracts already deployed.</p>
<ul>
<li>(1) L1 Chain
<ul>
<li>Chain 900</li>
</ul>
</li>
<li>(2) L2 Chains
<ul>
<li>Chain 901</li>
<li>Chain 902</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="first-steps"><a class="header" href="#first-steps">First steps</a></h1>
<p><code>supersim</code> allows testing multichain features <strong>locally</strong>. Previously, testing multichain features required complex docker setups or using a testnet.</p>
<p>To see it in practice, let's first try sending some ETH from the L1 to the L2.</p>
<h2 id="deposit-eth-from-the-l1-into-the-l2-l1-to-l2-message-passing"><a class="header" href="#deposit-eth-from-the-l1-into-the-l2-l1-to-l2-message-passing">Deposit ETH from the L1 into the L2 (L1 to L2 message passing)</a></h2>
<p><strong>1. Check initial balance on the L2 (chain 901)</strong></p>
<p>Grab the balance of the sender account on L2:</p>
<pre><code class="language-sh">cast balance 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 --rpc-url http://127.0.0.1:9545
</code></pre>
<br>
<p><strong>2. Send the Ether</strong>
<br />
It exists two  different methods to do this action</p>
<h3 id="first-method---optimismportal"><a class="header" href="#first-method---optimismportal">First method - <code>OptimismPortal</code></a></h3>
<p>Send the Ether to <code>OptimismPortal</code> contract of the respective L2 (on chain 900)**</p>
<p>Initiate a bridge transaction on the L1:<br>
<em>In the case of the chain 901 the contract is <code>0x37a418800d0c812A9dE83Bc80e993A6b76511B57</code></em></p>
<pre><code class="language-sh">cast send 0x37a418800d0c812A9dE83Bc80e993A6b76511B57 --value 0.1ether --rpc-url http://127.0.0.1:8545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
</code></pre>
<h3 id="second-method---l1standardbridge"><a class="header" href="#second-method---l1standardbridge">Second method - <code>L1StandardBridge</code></a></h3>
<p><strong>Call <code>bridgeETH</code> function on the <code>L1StandardBridgeProxy</code> / <code>L1StandardBridge</code> contract of the respective L2 on L1 (chain 900)</strong>
<em>In the case of the chain 901 the contract is <code>0x8d515eb0e5F293B16B6bBCA8275c060bAe0056B0</code></em></p>
<p>Initiate a bridge transaction on the L1:</p>
<pre><code class="language-sh">cast send 0x8d515eb0e5F293B16B6bBCA8275c060bAe0056B0 "bridgeETH(uint32 _minGasLimit, bytes calldata _extraData)" 50000 0x --value 0.1ether --rpc-url http://127.0.0.1:8545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
</code></pre>
<br>
<p><strong>3. Check the balance on the L2 (chain 901)</strong></p>
<p>Verify that the ETH balance of the sender has increased on the L2:</p>
<pre><code class="language-sh">cast balance 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 --rpc-url http://127.0.0.1:9545
</code></pre>
<h2 id="send-an-interoperable-superchainerc20-token-from-chain-901-to-902-l2-to-l2-message-passing"><a class="header" href="#send-an-interoperable-superchainerc20-token-from-chain-901-to-902-l2-to-l2-message-passing">Send an interoperable SuperchainERC20 token from chain 901 to 902 (L2 to L2 message passing)</a></h2>
<p>In a typical L2 to L2 cross-chain transfer, two transactions are required:</p>
<ol>
<li>Send transaction on the source chain – This initiates the token transfer on Chain 901.</li>
<li>Relay message transaction on the destination chain – This relays the transfer details to Chain 902.</li>
</ol>
<p>To simplify this process, you can use the <code>--interop.autorelay</code> flag. This flag automatically triggers the relay message transaction once the initial send transaction is completed on the source chain, improving the developer experience by removing the need to manually send the relay message.</p>
<h3 id="1-start-supersim-with-the-autorelayer-enabled"><a class="header" href="#1-start-supersim-with-the-autorelayer-enabled">1. Start <code>supersim</code> with the autorelayer enabled</a></h3>
<pre><code class="language-sh">supersim --interop.autorelay 
</code></pre>
<h3 id="2-mint-tokens-to-transfer-on-chain-901"><a class="header" href="#2-mint-tokens-to-transfer-on-chain-901">2. Mint tokens to transfer on chain 901</a></h3>
<p>Run the following command to mint 1000 <code>L2NativeSuperchainERC20</code> tokens to the recipient address:</p>
<pre><code class="language-sh">cast send 0x420beeF000000000000000000000000000000001 "mint(address _to, uint256 _amount)"  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 1000  --rpc-url http://127.0.0.1:9545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80

</code></pre>
<h3 id="3-initiate-the-send-transaction-on-chain-901"><a class="header" href="#3-initiate-the-send-transaction-on-chain-901">3. Initiate the send transaction on chain 901</a></h3>
<p>Send the tokens from Chain 901 to Chain 902 using the following command:</p>
<pre><code class="language-sh">cast send 0x4200000000000000000000000000000000000028 "sendERC20(address _token, address _to, uint256 _amount, uint256 _chainId)" 0x420beeF000000000000000000000000000000001 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 1000 902 --rpc-url http://127.0.0.1:9545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
</code></pre>
<h3 id="4-wait-for-the-relayed-message-to-appear-on-chain-902"><a class="header" href="#4-wait-for-the-relayed-message-to-appear-on-chain-902">4. Wait for the relayed message to appear on chain 902</a></h3>
<p>In a few seconds, you should see the RelayedMessage on chain 902:</p>
<pre><code class="language-sh"># example
INFO [08-30|14:30:14.698] SuperchainTokenBridge#RelayERC20 token=0x420beeF000000000000000000000000000000001 from=0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 to=0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 amount=1000 source=901
</code></pre>
<h3 id="5-check-the-balance-on-chain-902"><a class="header" href="#5-check-the-balance-on-chain-902">5. Check the balance on chain 902</a></h3>
<p>Verify that the balance of the L2NativeSuperchainERC20 on chain 902 has increased:</p>
<pre><code class="language-sh">cast balance --erc20 0x420beeF000000000000000000000000000000001 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 --rpc-url http://127.0.0.1:9546
</code></pre>
<p>With the steps above, you've now successfully completed both an L1 to L2 ETH bridge and an L2 to L2 interoperable SuperchainERC20 token transfer, all done locally using <code>supersim</code>. This approach simplifies multichain testing, allowing you to focus on development without the need for complex setups or relying on external testnets.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- omit in toc -->
<h1 id="supersim-vanilla-mode"><a class="header" href="#supersim-vanilla-mode">supersim (vanilla mode)</a></h1>
<ul>
<li><a href="reference/supersim.html#overview">Overview</a></li>
<li><a href="reference/supersim.html#configuration">Configuration</a></li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Start supersim in vanilla (non-forked) mode</p>
<pre><code class="language-sh">supersim
</code></pre>
<p>Vanilla mode will start 3 chains, with the OP Stack contracts &amp; periphery contracts already deployed.</p>
<ul>
<li>(1) L1 Chain
<ul>
<li>Chain 900</li>
</ul>
</li>
<li>(2) L2 Chains
<ul>
<li>Chain 901</li>
<li>Chain 902</li>
</ul>
</li>
</ul>
<p><strong>Example startup logs</strong></p>
<pre><code>Available Accounts
-----------------------
(0): 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
(1): 0x70997970C51812dc3A010C7d01b50e0d17dc79C8
(2): 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC
(3): 0x90F79bf6EB2c4f870365E785982E1f101E93b906
(4): 0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65
(5): 0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc
(6): 0x976EA74026E726554dB657fA54763abd0C3a0aa9
(7): 0x14dC79964da2C08b23698B3D3cc7Ca32193d9955
(8): 0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f
(9): 0xa0Ee7A142d267C1f36714E4a8F75612F20a79720

Private Keys
-----------------------
(0): 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
(1): 0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d
(2): 0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a
(3): 0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6
(4): 0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a
(5): 0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba
(6): 0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e
(7): 0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356
(8): 0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97
(9): 0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6

Orchestrator Config:
L1:
  Name: L1    Chain ID: 900    RPC: http://127.0.0.1:8545    LogPath: /var/folders/0w/ethers-phoenix/T/anvil-chain-900
L2:
  Name: OPChainA    Chain ID: 901    RPC: http://127.0.0.1:9545    LogPath: /var/folders/0w/ethers-phoenix/T/anvil-chain-901
  Name: OPChainB    Chain ID: 902    RPC: http://127.0.0.1:9546    LogPath: /var/folders/0w/ethers-phoenix/T/anvil-chain-902
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<pre><code>NAME:
   supersim - Superchain Multi-L2 Simulator

USAGE:
   supersim [global options] command [command options]

VERSION:
   untagged

DESCRIPTION:
   Local multichain optimism development environment

COMMANDS:
   fork     Locally fork a network in the superchain registry
   help, h  Shows a list of commands or help for one command

GLOBAL OPTIONS:

    --interop.autorelay                 (default: false)                   ($SUPERSIM_INTEROP_AUTORELAY)
          Automatically relay messages sent to the L2ToL2CrossDomainMessenger using
          account 0xa0Ee7A142d267C1f36714E4a8F75612F20a79720

    --interop.delay value               (default: 0)                       ($SUPERSIM_INTEROP_DELAY)
          Delay before relaying messages sent to the L2ToL2CrossDomainMessenger

    --l1.port value                     (default: 8545)                    ($SUPERSIM_L1_PORT)
          Listening port for the L1 instance. `0` binds to any available port

    --l2.starting.port value            (default: 9545)                    ($SUPERSIM_L2_STARTING_PORT)
          Starting port to increment from for L2 chains. `0` binds each chain to any
          available port

    --log.color                         (default: false)                   ($SUPERSIM_LOG_COLOR)
          Color the log output if in terminal mode

    --log.format value                  (default: text)                    ($SUPERSIM_LOG_FORMAT)
          Format the log output. Supported formats: 'text', 'terminal', 'logfmt', 'json',
          'json-pretty',

    --log.level value                   (default: INFO)                    ($SUPERSIM_LOG_LEVEL)
          The lowest log level that will be output

    --log.pid                           (default: false)                   ($SUPERSIM_LOG_PID)
          Show pid in the log

    --logs.directory value                                                 ($SUPERSIM_LOGS_DIRECTORY)
          Directory to store logs

    --odyssey.enabled                   (default: false)                   ($SUPERSIM_ODYSSEY_ENABLED)
          Enable odyssey experimental features

   MISC


    --help, -h                          (default: false)
          show help

    --version, -v                       (default: false)
          print the version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- omit in toc -->
<h1 id="supersim-fork-forked-mode"><a class="header" href="#supersim-fork-forked-mode">supersim fork (forked mode)</a></h1>
<ul>
<li><a href="reference/supersim-fork.html#overview">Overview</a></li>
<li><a href="reference/supersim-fork.html#configuration">Configuration</a></li>
<li><a href="reference/supersim-fork.html#notes">Notes</a>
<ul>
<li><a href="reference/supersim-fork.html#fork-height">Fork height</a></li>
<li><a href="reference/supersim-fork.html#interoperability-contracts">Interoperability contracts</a></li>
</ul>
</li>
</ul>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<pre><code class="language-sh">supersim fork
</code></pre>
<p>The supersim fork command simplifies the process of forking multiple chains in the Superchain ecosystem simultaneously. It determines the appropriate block heights for each chain and launches both the L1 and L2 chains based on these values.</p>
<p>If you're relying on contracts already deployed on testnet / mainnet chains, you can use fork mode to simulate and interact with the state of the chain without needing to re-deploy or modify the contracts.</p>
<p>Locally fork any of the available chains in a superchain network of the <a href="https://github.com/ethereum-optimism/superchain-registry">superchain registry</a>, default <code>mainnet</code> versions.</p>
<p><strong>Example startup logs</strong></p>
<pre><code>Available Accounts
-----------------------
(0): 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
--- truncated for brevity ---

Private Keys
-----------------------
(0): 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
--- truncated for brevity ---

Orchestrator Config:
L1:
  Name: mainnet    Chain ID: 1    RPC: http://127.0.0.1:8545    LogPath: /var/folders/0w/ethers-phoenix/T/anvil-chain-1-1521250718
L2:
  Name: op    Chain ID: 10    RPC: http://127.0.0.1:9545    LogPath: /var/folders/0w/ethers-phoenix/T/anvil-chain-10
  Name: base    Chain ID: 8453    RPC: http://127.0.0.1:9546    LogPath: /var/folders/0w/ethers-phoenix/T/anvil-chain-8453
  Name: zora    Chain ID: 7777777    RPC: http://127.0.0.1:9547    LogPath: /var/folders/0w/ethers-phoenix/T/anvil-chain-7777777
</code></pre>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<pre><code>NAME:
   supersim fork - Locally fork a network in the superchain registry

USAGE:
   supersim fork [command options]

OPTIONS:

          --l1.fork.height value              (default: 0)                       ($SUPERSIM_L1_FORK_HEIGHT)
                L1 height to fork the superchain (bounds L2 time). `0` for latest

          --chains value                                                         ($SUPERSIM_CHAINS)
                chains to fork in the superchain, mainnet options: [base, lyra, metal, mode, op,
                orderly, race, tbn, zora]. In order to replace the public rpc endpoint for a
                chain, specify the ($SUPERSIM_RPC_URL_&lt;CHAIN&gt;) env variable. i.e
                SUPERSIM_RPC_URL_OP=http://optimism-mainnet.infura.io/v3/&lt;API-KEY&gt;

          --network value                     (default: "mainnet")               ($SUPERSIM_NETWORK)
                superchain network. options: mainnet, sepolia, sepolia-dev-0. In order to
                replace the public rpc endpoint for the network, specify the
                ($SUPERSIM_RPC_URL_&lt;NETWORK&gt;) env variable. i.e
                SUPERSIM_RPC_URL_MAINNET=http://mainnet.infura.io/v3/&lt;API-KEY&gt;

          --interop.enabled                   (default: true)                    ($SUPERSIM_INTEROP_ENABLED)
                enable interop predeploy and functionality

          --l1.port value                     (default: 8545)                    ($SUPERSIM_L1_PORT)
                Listening port for the L1 instance. `0` binds to any available port

          --l2.starting.port value            (default: 9545)                    ($SUPERSIM_L2_STARTING_PORT)
                Starting port to increment from for L2 chains. `0` binds each chain to any
                available port

          --interop.autorelay                 (default: false)                   ($SUPERSIM_INTEROP_AUTORELAY)
                Automatically relay messages sent to the L2ToL2CrossDomainMessenger using
                account 0xa0Ee7A142d267C1f36714E4a8F75612F20a79720
          
          --interop.delay value               (default: 0)                       ($SUPERSIM_INTEROP_DELAY)
                Delay before relaying messages sent to the L2ToL2CrossDomainMessenger

          --logs.directory value                                                 ($SUPERSIM_LOGS_DIRECTORY)
                Directory to store logs

          --log.level value                   (default: INFO)                    ($SUPERSIM_LOG_LEVEL)
                The lowest log level that will be output

          --log.format value                  (default: text)                    ($SUPERSIM_LOG_FORMAT)
                Format the log output. Supported formats: 'text', 'terminal', 'logfmt', 'json',
                'json-pretty',

          --log.color                         (default: false)                   ($SUPERSIM_LOG_COLOR)
                Color the log output if in terminal mode

          --log.pid                           (default: false)                   ($SUPERSIM_LOG_PID)
                Show pid in the log

          --odyssey.enabled                   (default: false)                   ($SUPERSIM_ODYSSEY_ENABLED)
                Enable odyssey experimental features

          --help, -h                          (default: false)
                show help
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<h3 id="fork-height"><a class="header" href="#fork-height">Fork height</a></h3>
<p>The fork height is determined by L1 block height (default <code>latest</code>). This is then used to derive the corresponding L2 block to start from.</p>
<h3 id="interoperability-contracts"><a class="header" href="#interoperability-contracts">Interoperability contracts</a></h3>
<p>By default, interop contracts are not deployed on forked networks. To include them, run supersim with the <code>--interop.enabled</code> flag.</p>
<pre><code class="language-sh">supersim fork --chains=op,base,zora --interop.enabled
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- omit in toc -->
<h1 id="included-contracts"><a class="header" href="#included-contracts">Included contracts</a></h1>
<p>The chain environment includes contracts already deployed to help replicate the Superchain environment.</p>
<ul>
<li><a href="chain-environment/contracts/index.html#op-stack-system-contracts-l1">OP Stack system contracts (L1)</a></li>
<li><a href="chain-environment/contracts/index.html#op-stack-l2-contracts-l2">OP Stack L2 contracts (L2)</a></li>
<li><a href="chain-environment/contracts/index.html#periphery-contracts-l2">Periphery contracts (L2)</a>
<ul>
<li><a href="chain-environment/contracts/index.html#l2nativesuperchainerc20">L2NativeSuperchainERC20</a>
<ul>
<li><a href="chain-environment/contracts/index.html#minting-new-tokens">Minting new tokens</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="op-stack-system-contracts-l1"><a class="header" href="#op-stack-system-contracts-l1">OP Stack system contracts (L1)</a></h2>
<p>These are the L1 contracts that are required for a rollup as part of the OP Stack protocol. Examples are the <a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L1/OptimismPortal.sol">OptimismPortal</a>, <a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L1/L1StandardBridge.sol">L1StandardBridge</a>, and <a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L1/L1CrossDomainMessenger.sol">L1CrossDomainMessenger</a>.</p>
<p>View examples of these contracts here the official <a href="https://docs.optimism.io/chain/addresses#ethereum-l1">OP docs</a> or the source code <a href="https://github.com/ethereum-optimism/optimism/tree/develop/packages/contracts-bedrock/src/L1">here in the Optimism monorepo</a></p>
<h2 id="op-stack-l2-contracts-l2"><a class="header" href="#op-stack-l2-contracts-l2">OP Stack L2 contracts (L2)</a></h2>
<p>The OP Stack system contracts on the L2 are included at the standard addresses by default.</p>
<ul>
<li><a href="https://specs.optimism.io/protocol/predeploys.html">Standard OP Stack predeploys (L2)</a></li>
<li><a href="https://specs.optimism.io/interop/predeploys.html">Interoperability predeploys (<em>experimental</em>) (L2)</a></li>
<li><a href="https://specs.optimism.io/protocol/preinstalls.html">OP Stack preinstalls (L2)</a></li>
</ul>
<h2 id="periphery-contracts-l2"><a class="header" href="#periphery-contracts-l2">Periphery contracts (L2)</a></h2>
<p>L2 chains running on <code>supersim</code> also includes some useful contracts for testing purposes that are not part of the OP Stack by default.</p>
<h3 id="l2nativesuperchainerc20"><a class="header" href="#l2nativesuperchainerc20">L2NativeSuperchainERC20</a></h3>
<p>A simple ERC20 that adheres to the SuperchainERC20 standard. It includes permissionless minting for easy testing.</p>
<p>Source: <a href="https://github.com/ethereum-optimism/supersim/blob/main/contracts/src/L2NativeSuperchainERC20.sol">L2NativeSuperchainERC20.sol</a></p>
<p>Deployed address: <code>0x420beeF000000000000000000000000000000001</code></p>
<h4 id="minting-new-tokens"><a class="header" href="#minting-new-tokens">Minting new tokens</a></h4>
<pre><code class="language-bash">cast send 0x420beeF000000000000000000000000000000001 "mint(address _to, uint256 _amount)" $RECIPIENT_ADDRESS 1ether  --rpc-url $L2_RPC_URL
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network-details"><a class="header" href="#network-details">Network details</a></h1>
<p>By default, two OP Stack systems will be spun up in vanilla mode</p>
<ul>
<li>OPChainA (chainID 901)</li>
<li>OPChainB (chainID 902)</li>
</ul>
<p>Both "roll up" into a single L1 chain (chainID 900).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deposit-transactions"><a class="header" href="#deposit-transactions">Deposit transactions</a></h1>
<p>Supersim supports deposits transactions as described in the <a href="https://docs.optimism.io/stack/transactions/deposit-flow">explainer</a>. However in a very lightweight manner without the op-node derivation pipeline by listening directly to the <code>TransactionDeposited</code> events on the OptimsimPortal contract and simply forwarding the transaction to the applicable L2.</p>
<p>This implies the execution engine used with Supersim must support the optimism <a href="https://specs.optimism.io/protocol/deposits.html#the-deposited-transaction-type">Deposit Transaction Type</a>.</p>
<h2 id="optimismportal"><a class="header" href="#optimismportal">OptimismPortal</a></h2>
<p>When starting Supersim, the L1 contracts for each L2 chain are emitted as output to the console. The <code>L1CrossDomainMessenger</code>, <code>L1StandardBridge</code>, and <code>OptimismPortal</code> can be used to initiate deposits in the same manner as one would on a production network like OP Mainnet or Base.</p>
<pre><code class="language-bash">Chain Configuration
-----------------------
L1: Name: Local  ChainID: 900  RPC: http://127.0.0.1:8545  LogPath: ...

L2: Predeploy Contracts Spec ( https://specs.optimism.io/protocol/predeploys.html )

  * Name: OPChainA  ChainID: 901  RPC: http://127.0.0.1:9545  LogPath: ...
    L1 Contracts:
     - OptimismPortal:         0x37a418800d0c812A9dE83Bc80e993A6b76511B57
     - L1CrossDomainMessenger: 0xcd712b03bc6424BF45cE6C29Fc90FFDece228F6E
     - L1StandardBridge:       0x8d515eb0e5F293B16B6bBCA8275c060bAe0056B0

  ...
</code></pre>
<p>If running Supersim in fork mode, the production contracts will be used for each of the forked networks.</p>
<pre><code class="language-bash">Chain Configuration
-----------------------
L1: Name: mainnet  ChainID: 1  RPC: http://127.0.0.1:8545  LogPath: ...

L2: Predeploy Contracts Spec ( https://specs.optimism.io/protocol/predeploys.html )

  * Name: op  ChainID: 10  RPC: http://127.0.0.1:9545  LogPath: ...
    L1 Contracts:
     - OptimismPortal:         0xbEb5Fc579115071764c7423A4f12eDde41f106Ed
     - L1CrossDomainMessenger: 0x25ace71c97B33Cc4729CF772ae268934F7ab5fA1
     - L1StandardBridge:       0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1

  * Name: mode  ChainID: 34443  RPC: http://127.0.0.1:9546  LogPath: ...
    L1 Contracts:
     - OptimismPortal:         0x8B34b14c7c7123459Cf3076b8Cb929BE097d0C07
     - L1CrossDomainMessenger: 0x95bDCA6c8EdEB69C98Bd5bd17660BaCef1298A6f
     - L1StandardBridge:       0x735aDBbE72226BD52e818E7181953f42E3b0FF21

   ...
</code></pre>
<h2 id="sample-deposit-flow"><a class="header" href="#sample-deposit-flow">Sample Deposit Flow</a></h2>
<p>We'll run through a sample deposit directly with the optimism portal using cast</p>
<ol>
<li><strong>Run Supersim</strong></li>
</ol>
<pre><code class="language-bash">supersim
</code></pre>
<ol start="2">
<li><strong>Observe OptimismPortal Contract Address</strong></li>
</ol>
<pre><code class="language-bash">...
* Name: OPChainA  ChainID: 901 ...
    L1 Contracts:
     - OptimismPortal: 0x37a418800d0c812A9dE83Bc80e993A6b76511B57
...
</code></pre>
<ol start="3">
<li><strong>Send Deposit Transaction On L1</strong></li>
</ol>
<p>We'll be using the first pre-funded account to send this deposit with 1 ether</p>
<pre><code class="language-bash">cast send 0x37a418800d0c812A9dE83Bc80e993A6b76511B57 --value 1ether --rpc-url http://localhost:8545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
</code></pre>
<ol start="4">
<li><strong>Verify With Supersim Logs</strong></li>
</ol>
<pre><code class="language-bash">INFO [11-28|13:56:06.756] OptimismPortal#depositTransaction chain.id=901 l2TxHash=0x592d6e13016751332115df1fce59904176bfe447854196ed1b97ee00f14be469
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interoperability"><a class="header" href="#interoperability">Interoperability</a></h1>
<div style="break-before: page; page-break-before: always;"></div><!-- omit in toc -->
<h1 id="cross-chain-contract-calls-pingpong"><a class="header" href="#cross-chain-contract-calls-pingpong">Cross Chain Contract Calls (PingPong)</a></h1>
<p>This guide walks through the <code>CrossChainPingPong.sol</code> contract, focusing on high level design and steps on integrating the <code>L2ToL2CrossChainMessenger</code> contract. The source code can be found <a href="https://github.com/ethereum-optimism/supersim/blob/main/contracts/src/pingpong/CrossChainPingPong.sol">here</a>.</p>
<ul>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#high-level-overview">High level overview</a>
<ul>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#diagram">Diagram</a></li>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#flow">Flow</a>
<ul>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#1-contract-deployment">1. Contract Deployment</a></li>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#2-hit-the-ball-starting-move">2. Hit the Ball (Starting Move)</a></li>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#3-receive-on-destination-chain">3. Receive on Destination Chain</a></li>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#4-continue-game-hit">4. Continue Game (Hit)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#walkthrough">Walkthrough</a>
<ul>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#initializing-contract-state">Initializing contract state</a>
<ul>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#constructor-setup">Constructor Setup</a></li>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#reliance-on-create2-for-cross-chain-consistency">Reliance on CREATE2 for cross chain consistency</a></li>
</ul>
</li>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#hitting-the-ball">Hitting the ball</a>
<ul>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#1-hitting-constraints">1. Hitting Constraints</a></li>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#2-define-the-receiving-handler">2. Define The Receiving Handler</a></li>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#3-hit-the-ball-cross-chain">3. Hit the Ball Cross Chain</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="guides/interop/cross-chain-contract-calls-pingpong.html#takeaways">Takeaways</a></li>
</ul>
<h2 id="high-level-overview"><a class="header" href="#high-level-overview">High level overview</a></h2>
<p><code>CrossChainPingPong.sol</code> implements a cross-chain ping-pong game using the L2ToL2CrossDomainMessenger.</p>
<ul>
<li>Players hit a virtual ** <em>ball</em> ** back and forth between allowed L2 chains. The game starts with a serve</li>
<li>from a designated start chain, and each hit increases the rally count. The contract tracks the last hitter's address, chain ID, and the current rally count.</li>
</ul>
<h3 id="diagram"><a class="header" href="#diagram">Diagram</a></h3>
<pre class="mermaid">sequenceDiagram
    participant Chain1 as Chain 1
    participant Chain2 as Chain 2
    
    Note over Chain1: 🚀 Game Starts (starting chain)
    Note over Chain1: 🏓 Hit Ball
    Chain1-&gt;&gt;Chain2: 📤 Send PingPongBall {rallyCount: 1, lastHitter: Chain1}
    Chain1--&gt;&gt;Chain1: Emit BallSent event
    activate Chain2
    Note over Chain2: 📥 Receive Ball
        Chain2--&gt;&gt;Chain2: Emit BallReceived event

    Note over Chain2: 🏓 Hit Ball
    Chain2-&gt;&gt;Chain1: 📤 Send PingPongBall {rallyCount: 2, lastHitter: Chain2}
    Chain2--&gt;&gt;Chain2: Emit BallSent event
    deactivate Chain2
    activate Chain1
    Note over Chain1: 📥 Receive Ball
        Chain1--&gt;&gt;Chain1: Emit BallReceived event

    Note over Chain1,Chain2: Game continues...
</pre>
<h3 id="flow"><a class="header" href="#flow">Flow</a></h3>
<h4 id="1-contract-deployment"><a class="header" href="#1-contract-deployment">1. Contract Deployment</a></h4>
<ul>
<li>Deployed on all participating chains</li>
<li>Utilizes CREATE2 with the same parameter, <code>_serverChainId</code>, resulting in the same address and initial state.</li>
</ul>
<h4 id="2-hit-the-ball-starting-move"><a class="header" href="#2-hit-the-ball-starting-move">2. Hit the Ball (Starting Move)</a></h4>
<ul>
<li>Call <code>hitBallTo</code> on the chain with the ball, specifying a destination chain.</li>
<li>Contract uses <code>L2ToL2CrossDomainMessenger</code> to send the ball data to the specified chain.</li>
<li>The reference to the ball is deleted from the serving chain.</li>
</ul>
<h4 id="3-receive-on-destination-chain"><a class="header" href="#3-receive-on-destination-chain">3. Receive on Destination Chain</a></h4>
<ul>
<li>L2ToL2CrossDomainMessenger on destination chain calls <code>receiveBall</code>.</li>
<li>Contract verifies the message sender and origin.</li>
<li>Ball data is stored, indicating its presence on this chain.</li>
</ul>
<h4 id="4-continue-game-hit"><a class="header" href="#4-continue-game-hit">4. Continue Game (Hit)</a></h4>
<ul>
<li>Any user on the chain currently holding the ball calls <code>hitBallTo</code> to send it to another chain.</li>
<li>Contract updates the <code>PingPongBall</code> data (increment rally count, update last hitter).</li>
<li>Process repeats from step 2.</li>
</ul>
<h2 id="walkthrough"><a class="header" href="#walkthrough">Walkthrough</a></h2>
<p>Here's an explanation of the functions in the contract, with a focus on how it interacts with <code>L2ToL2CrossChainMessenger</code>.</p>
<h3 id="initializing-contract-state"><a class="header" href="#initializing-contract-state">Initializing contract state</a></h3>
<h4 id="constructor-setup"><a class="header" href="#constructor-setup">Constructor Setup</a></h4>
<pre><code class="language-solidity">constructor(uint256 _serverChainId) {
    if (block.chainid == _serverChainId) {
        ball = PingPongBall(1, block.chainid, msg.sender);
    }
}
</code></pre>
<p>If the starting chain, initialize the ball allowing it to be hittable.</p>
<h4 id="reliance-on-create2-for-cross-chain-consistency"><a class="header" href="#reliance-on-create2-for-cross-chain-consistency">Reliance on CREATE2 for cross chain consistency</a></h4>
<p>While not explicitly mentioned in the code, this contract's design implicitly assumes the use of CREATE2 for deployment. Here's why CREATE2 is crucial for this setup:</p>
<ol>
<li>
<p><strong>Predictable Addresses</strong>:
CREATE2 enables deployment at the same address on all chains, crucial for cross-chain message verification:</p>
<pre><code class="language-solidity">if (messenger.crossDomainMessageSender() != address(this)) revert InvalidCrossDomainSender();
</code></pre>
</li>
<li>
<p><strong>Self-referential Messaging</strong>:
The contract sends messages to itself on other chains:</p>
<pre><code class="language-solidity">messenger.sendMessage(_toChainId, address(this), _message);
</code></pre>
<p>This requires <code>address(this)</code> to be consistent across chains.</p>
</li>
<li>
<p><strong>Initialization State Considerations</strong>:</p>
<p>The starting chain id is apart of the initcode, meaning a deployment with a differing value would result in a different address via CREATE2. This is a nice feature as there's an implicit agreement on the starting chain from the address.</p>
<p>Without CREATE2, you would need to:</p>
<ul>
<li>Manually track contract addresses for each chain.</li>
<li>Implement a more complex initialization process to register contract addresses across chains.</li>
<li>Potentially redesign the security model that relies on address matching.</li>
</ul>
</li>
</ol>
<h3 id="hitting-the-ball"><a class="header" href="#hitting-the-ball">Hitting the ball</a></h3>
<p><code>hitBallTo</code>: This function is used to hit the ball, when present, to another chain</p>
<h4 id="1-hitting-constraints"><a class="header" href="#1-hitting-constraints">1. Hitting Constraints</a></h4>
<pre><code class="language-solidity">function hitBallTo(uint256 _toChainId) public {
    if (ball.lastHitterAddress == address(0)) revert BallNotPresent();
    if (_toChainId == block.chainid) revert InvalidDestination();
    ...
}
</code></pre>
<ul>
<li>The <code>ball</code> contract variable is populated on the chain, indicating its presence</li>
<li>The destination must be a different chain</li>
</ul>
<h4 id="2-define-the-receiving-handler"><a class="header" href="#2-define-the-receiving-handler">2. Define The Receiving Handler</a></h4>
<pre><code class="language-solidity">modifier onlyCrossDomainCallback() {
    if (msg.sender != address(messenger)) revert CallerNotL2ToL2CrossDomainMessenger();
    if (messenger.crossDomainMessageSender() != address(this)) revert InvalidCrossDomainSender();

    _;
}

function receiveBall(PingPongBall memory _ball) onlyCrossDomainCallback() external {
    // Hold reference to the ball
    ball = _ball;

    emit BallReceived(messenger.crossDomainMessageSource(), block.chainid, _ball);
}
</code></pre>
<ul>
<li>The handler simply stores reference to the received ball</li>
<li>The handler can only be invokable by the cross chain messenger</li>
<li>Since the contract is self-referential, the cross chain sender must be the same contract address</li>
</ul>
<h4 id="3-hit-the-ball-cross-chain"><a class="header" href="#3-hit-the-ball-cross-chain">3. Hit The Ball Cross Chain</a></h4>
<pre><code class="language-solidity">function hitBallTo(uint256 _toChainId) public {
    ...

    // Construct a new ball
    PingPongBall memory newBall = PingPongBall(ball.rallyCount + 1, block.chainid, msg.sender);

    // Delete current reference
    delete ball;

    // Send to the destination
    messenger.sendMessage(_toChainId, address(this), abi.encodeCall(this.receiveBall, (newBall)));

    emit BallSent(block.chainid, _toChainId, newBall);
}
</code></pre>
<ul>
<li>Populate a new ball with updated properties</li>
<li>Delete reference to the current ball so it's no longer hittable</li>
<li>Invoke the contract on the destination chain matching the <code>receiveBall</code> handler defined in (2).</li>
</ul>
<h2 id="takeaways"><a class="header" href="#takeaways">Takeaways</a></h2>
<p>This is just one of many patterns to use the L2ToL2CrossDomainMessenger in your contract to power cross chain calls. Key points to remember:</p>
<ol>
<li>
<p><strong>Simple Message Passing</strong>: This design sends simple messages between identical contracts on different chains. Each message contains only the essential game state (rally count, last hitter). More complex systems might involve multiple contracts, intermediary relayers.</p>
</li>
<li>
<p><strong>Cross Chain Sender Verification</strong>: Always verify the sender of cross-chain messages. This includes checking both the immediate caller (the messenger) and the original sender on the source chain.</p>
</li>
<li>
<p><strong>Cross Chain Contract Coordination</strong>: This design uses CREATE2 for consistent contract addresses across chains, simplifying cross-chain verification. Alternative approaches include:</p>
<ul>
<li>Beacon proxy patterns for upgradeable contracts</li>
<li>Post-deployment setup where contract addresses are specified after deployment</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-chain-event-reading-tictactoe"><a class="header" href="#cross-chain-event-reading-tictactoe">Cross Chain Event Reading (TicTacToe)</a></h1>
<p>A horizontally scalable implementation of TicTacToe. This <a href="https://github.com/ethereum-optimism/supersim/blob/main/contracts/src/tictactoe/TicTacToe.sol">implementation</a> allows players to play each other from any chain without cross-chain calls, instead relying on cross-chain event reading. Since superchain interop can allow for event reading with a 1-block latency, the experience is the <strong>same as a single-chain implementation</strong></p>
<p>See the documentation for the <a href="https://github.com/ethereum-optimism/supersim/tree/main/examples/tictactoe">frontend</a> for how this game UI is presented to the player.</p>
<ul>
<li><a href="guides/interop/cross-chain-event-reads-tictactoe.html#how-it-works">How it works</a>
<ul>
<li><a href="guides/interop/cross-chain-event-reads-tictactoe.html#1-intent-to-play">1. Intent To Play</a></li>
<li><a href="guides/interop/cross-chain-event-reads-tictactoe.html#2-accepting-a-game">2. Accepting A Game</a></li>
<li><a href="guides/interop/cross-chain-event-reads-tictactoe.html#3-starting-the-game">3. Starting The Game</a></li>
<li><a href="guides/interop/cross-chain-event-reads-tictactoe.html#4-making-moves">4. Making Moves</a></li>
</ul>
</li>
<li><a href="guides/interop/cross-chain-event-reads-tictactoe.html#takeaways">Takeaways</a></li>
</ul>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>We use events to define the ordering of the a game with players only maintaining a local view. By default, a chain is also apart of its own interopble dependency set, <em>meaning players on the same chain can also play each other with no code changes</em>!</p>
<p>The system predeploy that enables pulling in validated cross-chain events is the <a href="https://specs.optimism.io/interop/predeploys.html#crossl2inbox">CrossL2Inbox</a>.</p>
<pre><code class="language-solidity">contract ICrossL2Inbox {
    function validateMessage(Identifier calldata _id, bytes32 _msgHash) external view;
}
</code></pre>
<p>This contract relies on a <strong>CREATE2</strong> deployment to ensure a consistent address across all chains, used to assert the origin of the pulled in game event.</p>
<h3 id="1-intent-to-play"><a class="header" href="#1-intent-to-play">1. Intent To Play</a></h3>
<p>A game is uniquely identified by the chain it was started from with a unqiue nonce. This identifier is included in all event fields such that each player can uniquely reference it locally.</p>
<p>To start a game, a player invokes <code>newGame</code> which broadcasts a <code>NewGame</code> event that any opponent <strong>on any chain</strong> can react to.</p>
<pre><code class="language-solidity">event NewGame(uint256 chainId, uint256 gameId, address player);

function newGame() external {
    emit NewGame(block.chainid, nextGameId, msg.sender);
    nextGameId++;
}
</code></pre>
<h3 id="2-accepting-a-game"><a class="header" href="#2-accepting-a-game">2. Accepting A Game</a></h3>
<p>When a <code>NewGame</code> event is observed, any player can declare their intent to play via <code>acceptGame</code>, referencing the <code>NewGame</code> event. An <code>AcceptedGame</code> event is emitted to signal to the creator that a game is ready to begin.</p>
<pre><code class="language-solidity">event AcceptedGame(uint256 chainId, uint256 gameId, address opponent, address player);

function acceptGame(ICrossL2Inbox.Identifier calldata _newGameId, bytes calldata _newGameData) external {
    if (_newGameId.origin != address(this)) revert IdOriginNotTicTacToe();
    ICrossL2Inbox(Predeploys.CROSS_L2_INBOX).validateMessage(_newGameId, keccak256(_newGameData));

    bytes32 selector = abi.decode(_newGameData[:32], (bytes32));
    if (selector != NewGame.selector) revert DataNotNewGame();

    ...

    emit AcceptedGame(chainId, gameId, game.opponent, game.player);
}
</code></pre>
<p>To prepare for the game, the event data is decoded and a local view of this game is stored.</p>
<pre><code class="language-solidity">(uint256 chainId, uint256 gameId, address opponent) = abi.decode(_newGameData[32:], (uint256, uint256, address));
if (opponent == msg.sender) revert SenderIsOpponent();

// Record Game Metadata (no moves)
Game storage game = games[chainId][gameId][msg.sender];
game.player = msg.sender;
game.opponent = opponent;
game.gameId = gameId;
game.lastOpponentId = _newGameId;
game.movesLeft = 9;

emit AcceptedGame(chainId, gameId, game.opponent, game.player);
</code></pre>
<h3 id="3-starting-the-game"><a class="header" href="#3-starting-the-game">3. Starting The Game</a></h3>
<p>As <code>AcceptedGame</code> events are emmited, the player must pick one opponent to play. The opponent's <code>AcceptedGame</code> event is used to instantiate the game and play the starting move via the <code>MovePlayed</code> event.</p>
<pre><code class="language-solidity">event MovePlayed(uint256 chainId, uint256 gameId, address player, uint8 _x, uint8 _y);

function startGame(ICrossL2Inbox.Identifier calldata _acceptedGameId, bytes calldata _acceptedGameData, uint8 _x, uint8 _y) external {
    if (_acceptedGameId.origin != address(this)) revert IdOriginNotTicTacToe();
    ICrossL2Inbox(Predeploys.CROSS_L2_INBOX).validateMessage(_acceptedGameId, keccak256(_acceptedGameData));

    bytes32 selector = abi.decode(_acceptedGameData[:32], (bytes32));
    if (selector != AcceptedGame.selector) revert DataNotAcceptedGame();

    ...

    emit MovePlayed(chainId, gameId, game.player, _x, _y);
</code></pre>
<p>The event fields contain the information required to perform the neccessary validation.</p>
<ul>
<li>The game identifier for lookup</li>
<li>The caller is the appropriate player</li>
<li>The player is accepting from the same starting chain</li>
</ul>
<pre><code class="language-solidity">(uint256 chainId, uint256 gameId, address player, address opponent) = // player, opponent swapped in local view
    abi.decode(_acceptedGameData[32:], (uint256, uint256, address, address));

// The accepted game was started from this chain, from the sender
if (chainId != block.chainid) revert GameChainMismatch();
if (msg.sender != player) revert SenderNotPlayer();

// Game has not already been started with an opponent.
Game storage game = games[chainId][gameId][msg.sender];
if (game.opponent != address(0)) revert GameStarted();

// Store local view of this game
...

// Locally record the move by the player with 1
game.moves[_x][_y] = 1;
game.lastOpponentId = _acceptedGameId;

emit MovePlayed(chainId, gameId, game.player, _x, _y);
</code></pre>
<h3 id="3-making-moves"><a class="header" href="#3-making-moves">3. Making Moves</a></h3>
<p>Once a game is started, players can continually make moves by invoking <code>makeMove</code>, reacting to a <code>MovePlayed</code> event of their opponent.</p>
<pre><code class="language-solidity">function makeMove(ICrossL2Inbox.Identifier calldata _movePlayedId, bytes calldata _movePlayedData, uint8 _x, uint8 _y) external {
    if (_movePlayedId.origin != address(this)) revert IdOriginNotTicTacToe();
    ICrossL2Inbox(Predeploys.CROSS_L2_INBOX).validateMessage(_movePlayedId, keccak256(_movePlayedData));

    bytes32 selector = abi.decode(_movePlayedData[:32], (bytes32));
    if (selector != MovePlayed.selector) revert DataNotMovePlayed();
}
</code></pre>
<p>Similar to <code>acceptGame</code>, validation is performed and the move of their opponent is first locally recorded.</p>
<ul>
<li>The game identifier for lookup</li>
<li>The caller is the player for this game</li>
<li>The opponent event corresponds to the same game</li>
<li>Ordering is enforced by ensuring that the supplied event is always forward progressing.</li>
</ul>
<pre><code class="language-solidity">(uint256 chainId, uint256 gameId,, uint8 oppX, uint8 oppY) = abi.decode(_movePlayedData[32:], (uint256, uint256, address, uint8, uint8));

// Game was instantiated for this player &amp; the move is for the same game
Game storage game = games[chainId][gameId][msg.sender];
if (game.player != msg.sender) revert GameNotExists();
if (game.gameId != gameId) revert GameNotExists();

// The move played event is forward progressing from the last observed event
if (_movePlayedId.chainId != game.lastOpponentId.chainId) revert IdChainMismatch();
if (_movePlayedId.blockNumber &lt;= game.lastOpponentId.blockNumber) revert MoveNotForwardProgressing();
game.lastOpponentId = _movePlayedId;

// Mark the opponents move
game.moves[oppX][oppY] = 2;
game.movesLeft--;
</code></pre>
<p>When a move is played we check if the game has been drawn or won, determining the subsequent event to emit.</p>
<p>The <code>makeMove</code> function is only callable when an opponent has a new <code>MovePlayed</code> event. Therefore, if the game is won or drawn, it cannot be progressed any further by the opponent.</p>
<pre><code class="language-solidity">// Make the players move
game.moves[_x][_y] = 1;
game.movesLeft--;

// Determine the status of the game
if (_isGameWon(game)) {
    emit GameWon(chainId, gameId, game.player, _x, _y);
} else if (game.movesLeft == 0) {
    emit GameDraw(chainId, gameId, game.player, _x, _y);
} else {
    emit MovePlayed(chainId, gameId, game.player, _x, _y);
}
</code></pre>
<h2 id="takeaways-1"><a class="header" href="#takeaways-1">Takeaways</a></h2>
<p>Leveraging superchain interop, we can build a new type of horizontally scalable contracts that do not rely on hub/spoke messaging with relayers.</p>
<ol>
<li>
<p>As new chains are added to the superchain, this contract can be installed by anyone and immediately playable with no necessary code changes. The frontend simply needs to react the addition of a new chain</p>
</li>
<li>
<p>The concept of a "chain" can be completely abstracted away from the user. When connecting their wallet, the frontend can simply pick the chain which the user has funds on with the lowest gas fees.</p>
</li>
<li>
<p>Event reading enables a new level of composability for cross-chain interactions! Imagine <a href="guides/interop/./cross-chain-event-composability-contests.html">contests</a> contract that resolves based on the outcome of a TicTacToe game via the <code>GameWon</code> or <code>GameLost</code> event without the need for a trusted oracle, nor permission or native integration with the TicTacToe contract.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-chain-event-composability-contests"><a class="header" href="#cross-chain-event-composability-contests">Cross Chain Event Composability (Contests)</a></h1>
<p>We showcase cross chain composability through the implementation of contests. Leveraging the same underlying mechanism powering TicTacToe, this contests can permissionlessly integrate with the events emitted by any contract in the Superchain.</p>
<p>See the documentation for the <a href="https://github.com/ethereum-optimism/supersim/tree/main/examples/contests">frontend</a> for how the contests UI is presented to the user.</p>
<ul>
<li><a href="guides/interop/cross-chain-event-composability-contests.html#how-it-works">How it works</a>
<ul>
<li><a href="guides/interop/cross-chain-event-composability-contests.html#blockhash-contest">BlockHash Contest</a></li>
<li><a href="guides/interop/cross-chain-event-composability-contests.html#tictactoe-contest">TicTacToe Contest</a></li>
</ul>
</li>
<li><a href="guides/interop/cross-chain-event-composability-contests.html#takeaways">Takeaways</a></li>
</ul>
<h2 id="how-it-works-1"><a class="header" href="#how-it-works-1">How it works</a></h2>
<p>Unlike TicTacToe which is deployed on every participating chain, the Contests is deployed on a single L2, behaving like an application-specific op-stack chain rather than a horizontally scaled app.</p>
<p><a href="https://github.com/ethereum-optimism/supersim/blob/main/contracts/src/contests/Contests.sol">Contests.sol</a> contains the implementation of the contests. We won't go into the details of the implementation here, but instead focus on how the contests can leverage cross chain event reading to compose with other contracts in the Superchain.</p>
<p>The system predeploy that enables pulling in validated cross-chain events is the <a href="https://specs.optimism.io/interop/predeploys.html#crossl2inbox">CrossL2Inbox</a>.</p>
<pre><code class="language-solidity">contract ICrossL2Inbox {
    function validateMessage(Identifier calldata _id, bytes32 _msgHash) external view;
}
</code></pre>
<p>A contest is identified by and has its outcome determined by the <code>IContestResolver</code> instance. The resolver starts in the <code>UNDECIDED</code> state, updated into <code>YES</code> or <code>NO</code> when resolving itself
with the contest.</p>
<pre><code class="language-solidity">enum ContestOutcome {
    UNDECIDED,
    YES,
    NO
}

interface IContestResolver {
    function outcome() external returns (ContestOutcome);
}
</code></pre>
<h3 id="blockhash-contest"><a class="header" href="#blockhash-contest">BlockHash Contest</a></h3>
<p>With the existence of an event that emits the blockhash and height of a block, we can create a contest on the parity of the blockhash being even or odd.</p>
<pre><code class="language-solidity">contract BlockHashEmitter {
    event BlockHash(uint256 blockHeight, bytes32 blockHash);

    function emitBlockHash(uint256 _blockHeight) external {
        bytes32 hash = blockhash(_blockHeight);
        require(hash != bytes32(0));

        emit BlockHash(_blockNumber, hash);
    }
}
</code></pre>
<p>Integrating this emitter into a contest is extremely simple.  The <code>BlockHashContestFactory</code> is a simple factory that creates a new contest for a given chain &amp; block height. When live, <strong>anyone</strong> can resolve the contest by simply providing the right <code>BlockHash</code> event to the deployed resolver.</p>
<pre><code class="language-solidity">contract BlockHashContestFactory {
    Contests         public contests;
    BlockHashEmitter public emitter; // Same emitter deployed on every chain

    function newContest(uint256 _chainId, uint256 _blockNumber) public payable {
        IContestResolver resolver = new BlockHashResolver(contests, emitter, _chainId, _blockNumber);
        contests.newContest{ value: msg.value }(resolver, msg.sender);
    }
}

contract BlockHashResolver is IContestResolver {
    Contests         public contests;
    ContestOutcome   public outcome;
    BlockHashEmitter public emitter;

    // The target chain &amp; block height
    uint256 public chainId;
    uint256 public blockNumber;

    function resolve(Identifier calldata _id, bytes calldata _data) external {
        require(outcome == ContestOutcome.UNDECIDED);

        // Validate Log
        require(_id.origin == address(emitter), "not an event from the emitter");
        require(_id.chainId == chainId, "must match target chain");
        CrossL2Inbox(Predeploys.CROSS_L2_INBOX).validateMessage(_id, keccak256(_data));

        bytes32 selector = abi.decode(_data[:32], (bytes32));
        require(selector == BlockHashEmitter.BlockHash.selector, "incorrect event");

        // Event should correspond to the right contest
        uint256 dataBlockNumber = abi.decode(_data[32:64], (uint256));
        require(dataBlockNumber == blockNumber, "must match target block height");

        // Resolve the contest (yes if odd, no if even)
        bytes32 blockHash = abi.decode(_data[64:], (bytes32));
        outcome = uint256(blockHash) % 2 != 0 ? ContestOutcome.YES : ContestOutcome.NO;
        contests.resolveContest(this);
    }

}
</code></pre>
<h3 id="tictactoe-contest"><a class="header" href="#tictactoe-contest">TicTacToe Contest</a></h3>
<p>A contest for TicTacToe is created on an accepted game between two players, captured by the emitted <code>AcceptedGame</code> event. When decoding the event, the game is uniquely identified by the chain it was created on, <code>chainId</code>, and the associated <code>gameId</code>. These identifying properties of the game are used to create the resolver for the game.</p>
<pre><code class="language-solidity">contract TicTacToeContestFactory {
    Contests  public contests;
    TicTacToe public tictactoe;

    function newContest(Identifier calldata _id, bytes calldata _data) public payable {
        // Validate Log
        require(_id.origin == address(tictactoe), "not an event from the TicTacToe contract");
        CrossL2Inbox(Predeploys.CROSS_L2_INBOX).validateMessage(_id, keccak256(_data));

        bytes32 selector = abi.decode(_data[:32], (bytes32));
        require(selector == TicTacToe.AcceptedGame.selector, "incorrect event");

        // Decode the event data
        (uint256 chainId, uint256 gameId, address creator,) = abi.decode(_data[32:], (uint256, uint256, address, address));

        IContestResolver resolver = new TicTacToeGameResolver(contest, tictactoe, chainId, gameId, creator);
        contests.newContest{ value: msg.value }(resolver, msg.sender);
    }
}
</code></pre>
<p>When live, <strong>anyone</strong> can resolve the contest by providing the <code>GameWon</code> or <code>GameDraw</code> event of the associated game from the TicTacToe contract.</p>
<pre><code class="language-solidity">contract TicTacToeGameResolver is IContestResolver {
    Contests       public contests;
    ContestOutcome public outcome;
    TicTacToe      public tictactoe;

    // @notice Game for this resolver
    Game public game;

    constructor(Contests _contest, TicTacToe _tictactoe, uint256 _chainId, uint256 _gameId, address _creator) {
        contest = _contest;
        tictactoe = _tictactoe;

        game = Game({chainId: _chainId, gameId: _gameId, creator: _creator});
        outcome = ContestOutcome.UNDECIDED;
    }

    // @notice resolve this game by providing the game ending event
    function resolve(Identifier calldata _id, bytes calldata _data) external {
        // Validate Log
        require(_id.origin == address(tictactoe));
        CrossL2Inbox(Predeploys.CROSS_L2_INBOX).validateMessage(_id, keccak256(_data));

        // Ensure this is a finalizing event
        bytes32 selector = abi.decode(_data[:32], (bytes32));
        require(selector == TicTacToe.GameWon.selector || selector == TicTacToe.GameDraw.selector, "event not a game outcome");

        // Event should correspond to the right game
        (uint256 _chainId, uint256 gameId, address winner,,) = abi.decode(_data[32:], (uint256, uint256, address, uint8, uint8));
        require(_chainId == game.chainId &amp;&amp; gameId == game.gameId);

        // Resolve based on if the creator has won (non-draw)
        outcome = winner == game.creator &amp;&amp; selector != TicTacToe.GameDraw.selector ? ContestOutcome.YES : ContestOutcome.NO;
        contests.resolveContest(this);
    }
}
</code></pre>
<h2 id="takeaways-2"><a class="header" href="#takeaways-2">Takeaways</a></h2>
<p>Leveraging superchain interop, contracts in the superchain can compose with each other in a similar fashion to how they would on a single chain. No restrictions are placed on the kinds of events a contract can consume via the <code>CrossL2Inbox</code>.</p>
<p>In this example, the <code>BlockHashContestFactory</code> and <code>TicTacToeContestFactory</code> can be seen as just starting points for the <code>Contests</code> app chain. As more contracts and apps are created in the superchain, this developer can compose with them in a similar fashion without needing to change the <code>Contests</code> contract at all!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bridging-eth"><a class="header" href="#bridging-eth">Bridging ETH</a></h1>
<p>Crosschain ETH transfers in the Superchain are facilitated through the <a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/SuperchainETHBridge.sol">SuperchainETHBridge</a> contract. For more information on this checkout the spec for SuperchainETHBridge: https://specs.optimism.io/interop/superchain-eth-bridge.html.</p>
<h2 id="cross-chain-eth-transfer-from-chain-901-to-902"><a class="header" href="#cross-chain-eth-transfer-from-chain-901-to-902">Cross-chain ETH transfer from chain 901 to 902</a></h2>
<p>This outlines how to send native ETH from chain 901 to 902. To simplify these steps supersim will be run with the <code>--interop.autorelay</code> flag. The <code>--interop.autorelay</code> flag automatically triggers the relay message transaction once the initial send transaction is completed on the source chain, improving the developer experience by removing the need to manually send the relay message.</p>
<h3 id="1-start-supersim-with-the-autorelayer-enabled-1"><a class="header" href="#1-start-supersim-with-the-autorelayer-enabled-1">1. Start <code>supersim</code> with the autorelayer enabled</a></h3>
<pre><code class="language-sh">supersim --interop.autorelay 
</code></pre>
<h3 id="2-initiate-the-send-transaction-on-chain-901-through-superchainethbridge-contract-deployed-at-0x4200000000000000000000000000000000000024"><a class="header" href="#2-initiate-the-send-transaction-on-chain-901-through-superchainethbridge-contract-deployed-at-0x4200000000000000000000000000000000000024">2. Initiate the send transaction on chain 901 through <code>SuperchainETHBridge</code> contract deployed at <code>0x4200000000000000000000000000000000000024</code></a></h3>
<p>Send ETH from Chain 901 to Chain 902 using the following command:</p>
<pre><code class="language-sh">cast send 0x4200000000000000000000000000000000000024 "sendETH(address _to, uint256 _chainId)" 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 902 --value 10ether --rpc-url http://127.0.0.1:9545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
</code></pre>
<h3 id="3-wait-for-the-relayed-message-to-appear-on-chain-902"><a class="header" href="#3-wait-for-the-relayed-message-to-appear-on-chain-902">3. Wait for the relayed message to appear on chain 902</a></h3>
<p>In a few seconds, you should see the relayed message on chain 902:</p>
<pre><code class="language-sh"># example
INFO [12-02|14:53:02.434] SuperchainETHBridge#RelayETH chain.id=902 from=0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 to=0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 amount=10,000,000,000,000,000,000 source=901
</code></pre>
<h3 id="4-check-the-balance-on-chain-902"><a class="header" href="#4-check-the-balance-on-chain-902">4. Check the balance on chain 902</a></h3>
<p>Verify that the balance of the ETH on chain 902 has increased:</p>
<pre><code class="language-sh">cast balance 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 --rpc-url http://127.0.0.1:9546
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- omit in toc -->
<h1 id="viem-to-send-and-relay-interop-messages"><a class="header" href="#viem-to-send-and-relay-interop-messages">Viem to send and relay interop messages</a></h1>
<p>This guide describes how to use <a href="https://viem.sh/"><code>viem</code></a> to send and relay interop messages using the <code>L2ToL2CrossDomainMessenger</code></p>
<p>We'll perform the SuperchainERC20 interop transfer in <a href="guides/interop/../../getting-started/first-steps.html#send-an-interoperable-superchainerc20-token-from-chain-901-to-902-l2-to-l2-message-passing">First steps</a> and <a href="guides/interop/./manually-relaying-interop-messages-cast.html">Manually relaying interop messages with <code>cast</code></a> again, this time using <code>viem</code> to relay the message without the autorelayer.</p>
<ul>
<li><a href="guides/interop/viem.html#steps">Steps</a>
<ul>
<li><a href="guides/interop/viem.html#1-start-supersim">1. Start <code>supersim</code></a></li>
<li><a href="guides/interop/viem.html#2-install-typescript-packages">2. Install TypeScript packages</a></li>
<li><a href="guides/interop/viem.html#3-define-chains-and-constants">3. Define chains and constants</a></li>
<li><a href="guides/interop/viem.html#4-mint-and-send-l2nativesuperchainerc20-on-source-chain">4. Mint and send <code>L2NativeSuperchainERC20</code> on source chain</a></li>
<li><a href="guides/interop/viem.html#5-relay-the-message-on-the-destination-chain">5. Relay the message on the destination chain</a></li>
</ul>
</li>
<li><a href="guides/interop/viem.html#full-code-snippet">Full code snippet</a></li>
</ul>
<h2 id="steps"><a class="header" href="#steps">Steps</a></h2>
<p>The full code snippet can be found <a href="guides/interop/viem.html#full-code-snippet">here</a></p>
<h3 id="1-start-supersim"><a class="header" href="#1-start-supersim">1. Start <code>supersim</code></a></h3>
<pre><code class="language-sh">supersim
</code></pre>
<h3 id="2-install-typescript-packages"><a class="header" href="#2-install-typescript-packages">2. Install TypeScript packages</a></h3>
<pre><code class="language-sh">npm i viem @eth-optimism/viem
</code></pre>
<h3 id="3-imports--setup"><a class="header" href="#3-imports--setup">3. Imports &amp; Setup</a></h3>
<pre><code class="language-ts">import {
	http,
	encodeFunctionData,
	createWalletClient,
	parseAbi,
	defineChain,
	publicActions,
} from "viem";
import { privateKeyToAccount } from "viem/accounts";
import {
    contracts,
	publicActionsL2,
	walletActionsL2,
    supersimL2A,
    supersimL2B,
    createInteropSentL2ToL2Messages,
    decodeRelayedL2ToL2Messages,
} from "@eth-optimism/viem";

// SuperERC20 is in development so we manually define the address here
const L2_NATIVE_SUPERCHAINERC20_ADDRESS = "0x420beeF000000000000000000000000000000001";
const SUPERCHAIN_TOKEN_BRIDGE_ADDRESS = "0x4200000000000000000000000000000000000028";

// Account for 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
const account = privateKeyToAccount("0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80");

// Define chains
// ... left out as we'll use the supersim chain definitions

// Configure clients with optimism extension
const opChainAClient = createWalletClient({
	transport: http(),
	chain: supersimL2A,
	account,
}).extend(walletActionsL2())
	.extend(publicActionsL2())
	.extend(publicActions);

const opChainBClient = createWalletClient({
	transport: http(),
	chain: supersimL2B,
	account,
}).extend(walletActionsL2())
	.extend(publicActionsL2())
	.extend(publicActions);
</code></pre>
<h3 id="4-mint-and-bridge-l2nativesuperchainerc20-from-source-chain"><a class="header" href="#4-mint-and-bridge-l2nativesuperchainerc20-from-source-chain">4. Mint and Bridge <code>L2NativeSuperchainERC20</code> from source chain</a></h3>
<pre><code class="language-ts">// #######
// OP Chain A
// #######

// 1. Mint 1000 `L2NativeSuperchainERC20` token on chain A

const mintTxHash = await opChainAClient.writeContract({
	address: L2_NATIVE_SUPERCHAINERC20_ADDRESS,
	abi: parseAbi(["function mint(address to, uint256 amount)"]),
	functionName: "mint",
	args: [account.address, 1000n],
});

await opChainAClient.waitForTransactionReceipt({ hash: mintTxHash });

// 2. Initiate sendERC20 tx to bridge funds to chain B

console.log("Initiating sendERC20 on OPChainA to OPChainB...");
const sendERC20TxHash = await opChainAClient.writeContract({
	address: SUPERCHAIN_TOKEN_BRIDGE_ADDRESS,
	abi: parseAbi([
		"function sendERC20(address _token, address _to, uint256 _amount, uint256 _chainId)",
	]),
	functionName: "sendERC20",
	args: [L2_NATIVE_SUPERCHAINERC20_ADDRESS, account.address, 1000n, BigInt(supersimL2B.id)],
});

const sendERC20Receipt = await opChainAClient.waitForTransactionReceipt({ hash: sendERC20TxHash });

// 3. Construct the interoperable log data from the sent message

const { sentMessages } = await createInteropSentL2ToL2Messages(opChainAClient, { receipt: sendERC20Receipt })
const sentMessage = sentMessages[0] // We only sent 1 message
</code></pre>
<h3 id="5-relay-the-sent-message-on-the-destination-chain"><a class="header" href="#5-relay-the-sent-message-on-the-destination-chain">5. Relay the sent message on the destination chain</a></h3>
<pre><code class="language-ts">
// ##########
// OP Chain B
// ##########

// 4. Relay the sent message

console.log("Relaying message on OPChainB...");
const relayTxHash = await opChainBClient.relayL2ToL2Message({
    sentMessageId: sentMessage.id,
    sentMessagePayload: sentMessage.payload,
});

const relayReceipt = await opChainBClient.waitForTransactionReceipt({ hash: relayTxHash });

// 5. Ensure the message was relayed successfully

const { successfulMessages, failedMessages } = decodeRelayedL2ToL2Messages({ receipt: relayReceipt });
if (successfulMessages.length != 1) {
    throw new Error("failed to relay message!")
}

// 6. Check balance on OPChainB
const balance = await opChainBClient.readContract({
	address: L2_NATIVE_SUPERCHAINERC20_ADDRESS,
	abi: parseAbi(["function balanceOf(address) view returns (uint256)"]),
	functionName: "balanceOf",
	args: [account.address],
});

console.log(`Balance on OPChainB: ${balance}`);
</code></pre>
<h2 id="full-code-snippet"><a class="header" href="#full-code-snippet">Full code snippet</a></h2>
<details>
  <summary>Click to view</summary>
<pre><code class="language-ts">// Using viem to transfer L2NativeSuperchainERC20

import {
	http,
	encodeFunctionData,
	createWalletClient,
	parseAbi,
	defineChain,
	publicActions,
} from "viem";
import { privateKeyToAccount } from "viem/accounts";
import {
    contracts,
	publicActionsL2,
	walletActionsL2,
    supersimL2A,
    supersimL2B,
    createInteropSentL2ToL2Messages,
    decodeRelayedL2ToL2Messages,
} from "@eth-optimism/viem";

// SuperERC20 is in development so we manually define the address here
const L2_NATIVE_SUPERCHAINERC20_ADDRESS =
	"0x420beeF000000000000000000000000000000001";

// account for 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
const account = privateKeyToAccount("0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80");

// Define chains
// ... left out as we'll use the supersim chain definitions

// Configure op clients
const opChainAClient = createWalletClient({
	transport: http(),
	chain: supersimL2A,
	account,
}).extend(walletActionsL2())
	.extend(publicActionsL2())
	.extend(publicActions);

const opChainBClient = createWalletClient({
	transport: http(),
	chain: supersimL2B,
	account,
}).extend(walletActionsL2())
	.extend(publicActionsL2())
	.extend(publicActions);

// #######
// OP Chain A
// #######

// 1. Mint 1000 `L2NativeSuperchainERC20` token

const mintTxHash = await opChainAClient.writeContract({
	address: L2_NATIVE_SUPERCHAINERC20_ADDRESS,
	abi: parseAbi(["function mint(address to, uint256 amount)"]),
	functionName: "mint",
	args: [account.address, 1000n],
});

await opChainAClient.waitForTransactionReceipt({ hash: mintTxHash });

// 2. Initiate sendERC20 tx to bridge funds to chain B

console.log("Initiating sendERC20 on OPChainA...");
const sendERC20TxHash = await opChainAClient.writeContract({
	address: SUPERCHAIN_TOKEN_BRIDGE_ADDRESS,
	abi: parseAbi([
		"function sendERC20(address _token, address _to, uint256 _amount, uint256 _chainId)",
	]),
	functionName: "sendERC20",
	args: [L2_NATIVE_SUPERCHAINERC20_ADDRESS, account.address, 1000n, BigInt(supersimL2B.id)],
});

const sendERC20Receipt = await opChainAClient.waitForTransactionReceipt({ hash: sendERC20TxHash });

// 3. Construct the interoperable log data from the sent message

const { sentMessages } = await createInteropSentL2ToL2Messages(opChainAClient, { receipt: sendERC20Receipt })
const sentMessage = sentMessages[0] // We only sent 1 message

// ##########
// OP Chain B
// ##########

// 4. Relay the sent message

console.log("Relaying message on OPChainB...");
const relayTxHash = await opChainBClient.relayL2ToL2Message({
    sentMessageId: sentMessage.id,
    sentMessagePayload: sentMessage.payload,
});

const relayReceipt = await opChainBClient.waitForTransactionReceipt({ hash: relayTxHash });

// 5. Ensure the message was relayed successfully

const { successfulMessages, failedMessages } = decodeRelayedL2ToL2Messages({ receipt: relayReceipt });
if (successfulMessages.length != 1) {
    throw new Error("failed to relay message!")
}

// 6. Check balance on OPChainB
const balance = await opChainBClient.readContract({
	address: L2_NATIVE_SUPERCHAINERC20_ADDRESS,
	abi: parseAbi(["function balanceOf(address) view returns (uint256)"]),
	functionName: "balanceOf",
	args: [account.address],
});

console.log(`Balance on OPChainB: ${balance}`);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- omit in toc -->
<h1 id="cast-commands-to-relay-interop-messages"><a class="header" href="#cast-commands-to-relay-interop-messages"><code>cast</code> commands to relay interop messages</a></h1>
<p>This guide describes how to form a <a href="https://specs.optimism.io/interop/messaging.html#message-identifier">message identifier</a> to relay a <a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/L2ToL2CrossDomainMessenger.sol">L2ToL2CrossDomainMessenger</a> cross chain call.</p>
<p>We'll perform the SuperchainERC20 interop transfer in <a href="guides/interop/../../getting-started/first-steps.html#send-an-interoperable-superchainerc20-token-from-chain-901-to-902-l2-to-l2-message-passing">First steps</a> again, this time manually relaying the message without the autorelayer.</p>
<ul>
<li><a href="guides/interop/cast.html#overview">Overview</a>
<ul>
<li><a href="guides/interop/cast.html#contracts-used">Contracts used</a></li>
<li><a href="guides/interop/cast.html#high-level-steps">High level steps</a></li>
<li><a href="guides/interop/cast.html#message-identifier">Message identifier</a></li>
</ul>
</li>
<li><a href="guides/interop/cast.html#steps">Steps</a>
<ul>
<li><a href="guides/interop/cast.html#1-start-supersim">1. Start <code>supersim</code></a></li>
<li><a href="guides/interop/cast.html#2-mint-tokens-to-transfer-on-chain-901">2. Mint tokens to transfer on chain 901</a></li>
<li><a href="guides/interop/cast.html#3-initiate-the-send-transaction-on-chain-901">3. Initiate the send transaction on chain 901</a></li>
<li><a href="guides/interop/cast.html#4-get-the-log-emitted-by-the-l2tol2crossdomainmessenger">4. Get the log emitted by the <code>L2ToL2CrossDomainMessenger</code></a></li>
<li><a href="guides/interop/cast.html#5-retrieve-the-block-timestamp-the-log-was-emitted-in">5. Retrieve the block timestamp the log was emitted in</a></li>
<li><a href="guides/interop/cast.html#6-prepare-the-message-identifier--payload">6. Prepare the message identifier &amp; payload</a></li>
<li><a href="guides/interop/cast.html#7-construct-the-access-list-for-the-message">7. Construct the access list for the message</a></li>
<li><a href="guides/interop/cast.html#8-send-the-relay-message-transaction">8. Send the relay message transaction</a></li>
<li><a href="guides/interop/cast.html#9-check-the-balance-on-chain-902">9. Check the balance on chain 902</a></li>
</ul>
</li>
<li><a href="guides/interop/cast.html#alternatives">Alternatives</a></li>
</ul>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<h3 id="contracts-used"><a class="header" href="#contracts-used">Contracts used</a></h3>
<ul>
<li><a href="https://github.com/ethereum-optimism/supersim/blob/main/contracts/src/L2NativeSuperchainERC20.sol">L2NativeSuperchainERC20</a>
<ul>
<li><code>0x420beeF000000000000000000000000000000001</code></li>
</ul>
</li>
<li><a href="https://github.com/ethereum-optimism/optimism/blob/92ed64e171c6eb9c6a080c626640e8836f0653cc/packages/contracts-bedrock/src/L2/L2ToL2CrossDomainMessenger.sol">L2ToL2CrossDomainMessenger</a>
<ul>
<li><code>0x4200000000000000000000000000000000000023</code></li>
</ul>
</li>
</ul>
<h3 id="high-level-steps"><a class="header" href="#high-level-steps">High level steps</a></h3>
<p>Sending an interop message using the <code>L2ToL2CrossDomainMessenger</code>:</p>
<p><strong>On source chain</strong> (OPChainA 901)</p>
<ol>
<li>Invoke <code>L2NativeSuperchainERC20.sentERC20</code> to bridge funds
<ul>
<li>this leverages <code>L2ToL2CrossDomainMessenger.sendMessage</code> to make the cross chain call</li>
</ul>
</li>
<li>Retrieve the log identifier and the message payload for the <code>SentMessage</code> event.</li>
</ol>
<p><strong>On destination chain</strong> (OPChainB 902)</p>
<ol start="3">
<li>Relay the message with <code>L2ToL2CrossDomainMessenger.relayMessage</code>
<ul>
<li>which then calls <code>L2NativeSuperchainERC20.relayERC20</code></li>
</ul>
</li>
</ol>
<h3 id="message-identifier"><a class="header" href="#message-identifier">Message identifier</a></h3>
<p>A message identifier uniquely identifies a log emitted on a chain.
The sequencer and smart contracts (CrossL2Inbox) use the identifier to perform <a href="https://specs.optimism.io/interop/messaging.html#messaging-invariants">invariant checks</a> to confirm that the message is valid.</p>
<pre><code class="language-solidity">struct Identifier {
    address origin;      // Account (contract) that emits the log
    uint256 blocknumber; // Block number in which the log was emitted
    uint256 logIndex;    // Index of the log in the array of all logs emitted in the block
    uint256 timestamp;   // Timestamp that the log was emitted
    uint256 chainid;     // Chain ID of the chain that emitted the log
}
</code></pre>
<h2 id="steps-1"><a class="header" href="#steps-1">Steps</a></h2>
<h3 id="1-start-supersim-1"><a class="header" href="#1-start-supersim-1">1. Start <code>supersim</code></a></h3>
<pre><code class="language-sh">supersim
</code></pre>
<h3 id="2-mint-tokens-to-transfer-on-chain-901-1"><a class="header" href="#2-mint-tokens-to-transfer-on-chain-901-1">2. Mint tokens to transfer on chain 901</a></h3>
<p>Run the following command to mint 1000 <code>L2NativeSuperchainERC20</code> tokens to the recipient address:</p>
<pre><code class="language-sh">cast send 0x420beeF000000000000000000000000000000001 "mint(address _to, uint256 _amount)"  0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 1000  --rpc-url http://127.0.0.1:9545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
</code></pre>
<h3 id="3-initiate-the-send-transaction-on-chain-901-1"><a class="header" href="#3-initiate-the-send-transaction-on-chain-901-1">3. Initiate the send transaction on chain 901</a></h3>
<p>Send the tokens from Chain 901 to Chain 902 using the following command:</p>
<pre><code class="language-sh">cast send 0x4200000000000000000000000000000000000028 "sendERC20(address _token, address _to, uint256 _amount, uint256 _chainId)" 0x420beeF000000000000000000000000000000001 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 1000 902 --rpc-url http://127.0.0.1:9545 --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
</code></pre>
<h3 id="4-get-the-log-emitted-by-the-l2tol2crossdomainmessenger"><a class="header" href="#4-get-the-log-emitted-by-the-l2tol2crossdomainmessenger">4. Get the log emitted by the <code>L2ToL2CrossDomainMessenger</code></a></h3>
<p>The token contract calls the <a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/L2ToL2CrossDomainMessenger.sol">L2ToL2CrossDomainMessenger</a>, which emits a message (log) that can be relayed on the destination chain.</p>
<pre><code class="language-sh">cast logs --address 0x4200000000000000000000000000000000000023 --rpc-url http://127.0.0.1:9545
</code></pre>
<p>Sample output:</p>
<pre><code>address: 0x4200000000000000000000000000000000000023
blockHash: 0x311f8ccea3fc121aa3af18e0a87766ae56ed3f1d08cae91ec29f34a9919abcc0
blockNumber: 14
data: 0x0000000000000000000000004200000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000847cfd6dbc000000000000000000000000420beef000000000000000000000000000000001000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb9226600000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000
logIndex: 2
removed: false
topics: [
  0x382409ac69001e11931a28435afef442cbfd20d9891907e8fa373ba7d351f320
  0x0000000000000000000000000000000000000000000000000000000000000386
  0x0000000000000000000000004200000000000000000000000000000000000028
  0x0000000000000000000000000000000000000000000000000000000000000000
]
transactionHash: 0x746a3e8a3a0ed0787367c3476269fa3050a2f9113637b563a4579fbc03efe5c4
transactionIndex: 0
</code></pre>
<h3 id="5-retrieve-the-block-timestamp-the-log-was-emitted-in"><a class="header" href="#5-retrieve-the-block-timestamp-the-log-was-emitted-in">5. Retrieve the block timestamp the log was emitted in</a></h3>
<p>Since the message identifier requires the block timestamp, fetch the block info to get the timestamp.</p>
<pre><code class="language-sh">cast block 0xREPLACE_WITH_CORRECT_BLOCKHASH --rpc-url http://127.0.0.1:9545
</code></pre>
<p>Sample output:</p>
<pre><code>// (truncated for brevity)

timestamp            1743801675

// ...
</code></pre>
<h3 id="6-prepare-the-message-identifier--payload"><a class="header" href="#6-prepare-the-message-identifier--payload">6. Prepare the message identifier &amp; payload</a></h3>
<p>Now we have all the information needed for the message (log) identifier.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Parameter</strong></th><th><strong>Value</strong></th><th><strong>Note</strong></th></tr></thead><tbody>
<tr><td>origin</td><td>0x4200000000000000000000000000000000000023</td><td>L2ToL2CrossDomainMessenger</td></tr>
<tr><td>blocknumber</td><td>14</td><td>from step 4</td></tr>
<tr><td>logIndex</td><td>2</td><td>from step 4</td></tr>
<tr><td>timestamp</td><td>1743801675</td><td>from step 5</td></tr>
<tr><td>chainid</td><td>901</td><td>OPChainA chainID</td></tr>
</tbody></table>
</div>
<p>The message payload is the concatenation of the [...topics, data] in order.</p>
<pre><code>0x + 382409ac69001e11931a28435afef442cbfd20d9891907e8fa373ba7d351f320
   + 0000000000000000000000000000000000000000000000000000000000000386
   + 0000000000000000000000004200000000000000000000000000000000000028
   + 0000000000000000000000000000000000000000000000000000000000000000
   + 0000000000000000000000004200000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000847cfd6dbc000000000000000000000000420beef000000000000000000000000000000001000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb9226600000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000
</code></pre>
<p>Payload:</p>
<pre><code>0x382409ac69001e11931a28435afef442cbfd20d9891907e8fa373ba7d351f3200000000000000000000000000000000000000000000000000000000000000386000000000000000000000000420000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000000000000000000000000000004200000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000847cfd6dbc000000000000000000000000420beef000000000000000000000000000000001000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb9226600000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000
</code></pre>
<h3 id="7-construct-the-access-list-for-the-message"><a class="header" href="#7-construct-the-access-list-for-the-message">7. Construct the access list for the message</a></h3>
<p>An access list must be passed along with the relay message tx. There are two admin RPC methods that can be used to construct the access list: <code>admin_getAccessListByMsgHash</code> and <code>admin_getAccessListForIdentifier</code> and.</p>
<p>a. To get the access list using the <code>admin_getAccessListByMsgHash</code> RPC method, call the method with the message hash.</p>
<ol>
<li>Retrieve the message hash from the supersim logs</li>
</ol>
<pre><code class="language-sh">INFO [04-04|14:21:15.587] L2ToL2CrossChainMessenger#SentMessage    sourceChainID=901 destinationChainID=902 nonce=0 sender=0x4200000000000000000000000000000000000028 target=0x4200000000000000000000000000000000000028 msgHash=0xccff97c17ef11d659d319cbc5780235ea03ef34b0fa34f40b208a9519f257379 txHash=0x746a3e8a3a0ed0787367c3476269fa3050a2f9113637b563a4579fbc03efe5c4
</code></pre>
<ol start="2">
<li>Call <code>admin_getAccessListByMsgHash</code> with the message hash.</li>
</ol>
<pre><code class="language-sh">cast rpc admin_getAccessListByMsgHash 0xccff97c17ef11d659d319cbc5780235ea03ef34b0fa34f40b208a9519f257379 --rpc-url http://localhost:8420
</code></pre>
<p>Sample output:</p>
<pre><code>{
  "accessList": [
    {
      "address": "0x4200000000000000000000000000000000000022",
      "storageKeys": [
        "0x010000000000000000000385000000000000000e0000000067f04d4b00000002",
        "0x03c6d2648cef120ce1d7ccf9f8d4042d6b25ff30a02e22d9ea2a47d2677ccb8d"
      ]
    }
  ]
}
</code></pre>
<p>b. To get the access list using the <code>admin_getAccessListForIdentifier</code> RPC method, call the method with the identifier and the message payload.</p>
<pre><code class="language-sh">cast rpc admin_getAccessListForIdentifier \
'{
  "origin": "0x4200000000000000000000000000000000000023",
  "blockNumber": "14",
  "logIndex": "2",
  "timestamp": "1743801675",
  "chainId": "901",
  "payload": "0x382409ac69001e11931a28435afef442cbfd20d9891907e8fa373ba7d351f3200000000000000000000000000000000000000000000000000000000000000386000000000000000000000000420000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000000000000000000000000000004200000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000847cfd6dbc000000000000000000000000420beef000000000000000000000000000000001000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb9226600000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000"
}' \
--rpc-url http://localhost:8420
</code></pre>
<p>Sample output:</p>
<pre><code>{
  "accessList": [
    {
      "address": "0x4200000000000000000000000000000000000022",
      "storageKeys": [
        "0x010000000000000000000385000000000000000e0000000067f04d4b00000002",
        "0x03c6d2648cef120ce1d7ccf9f8d4042d6b25ff30a02e22d9ea2a47d2677ccb8d"
      ]
    }
  ]
}
</code></pre>
<h3 id="8-send-the-relay-message-transaction"><a class="header" href="#8-send-the-relay-message-transaction">8. Send the relay message transaction</a></h3>
<p>Call <code>relayMessage</code> on the <a href="https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/L2ToL2CrossDomainMessenger.sol">L2ToL2CrossDomainMessenger</a> with the access list.</p>
<pre><code class="language-solidity">// L2ToL2CrossDomainMessenger.sol (truncated for brevity)

contract L2ToL2CrossDomainMessenger {

  // ...

  function relayMessage(
      ICrossL2Inbox.Identifier calldata _id,
      bytes calldata _sentMessage
  ) payable

  // ...
}
</code></pre>
<p><strong><code>relayMessage</code> parameters</strong></p>
<ul>
<li><code>ICrossL2Inbox.Identifier calldata _id</code>: identifier pointing to the <code>SentMessage</code> log on the source chain (from <a href="guides/interop/cast.html#6-prepare-the-message-identifier--payload">step 6</a>)</li>
<li><code>bytes memory _sentMessage</code>: message payload (from <a href="guides/interop/cast.html#6-prepare-the-message-identifier--payload">step 6</a>)</li>
</ul>
<p>Below is an example call, but make sure to replace them with the correct values you received in previous steps.</p>
<pre><code class="language-sh">cast send 0x4200000000000000000000000000000000000023 \
    "relayMessage((address, uint256, uint256, uint256, uint256), bytes)" \
    "(0x4200000000000000000000000000000000000023, 14, 2, 1743801675, 901)" \
    0x382409ac69001e11931a28435afef442cbfd20d9891907e8fa373ba7d351f3200000000000000000000000000000000000000000000000000000000000000386000000000000000000000000420000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000000000000000000000000000004200000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000847cfd6dbc000000000000000000000000420beef000000000000000000000000000000001000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb9226600000000000000000000000000000000000000000000000000000000000003e800000000000000000000000000000000000000000000000000000000 \
    --access-list '[{"address":"0x4200000000000000000000000000000000000022","storageKeys":["0x010000000000000000000385000000000000000e0000000067f04d4b00000002", "0x03c6d2648cef120ce1d7ccf9f8d4042d6b25ff30a02e22d9ea2a47d2677ccb8d"]}]' \
    --rpc-url http://127.0.0.1:9546 \
    --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
</code></pre>
<h3 id="9-check-the-balance-on-chain-902"><a class="header" href="#9-check-the-balance-on-chain-902">9. Check the balance on chain 902</a></h3>
<p>Verify that the balance of the L2NativeSuperchainERC20 on chain 902 has increased:</p>
<pre><code class="language-sh">cast balance --erc20 0x420beeF000000000000000000000000000000001 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 --rpc-url http://127.0.0.1:9546
</code></pre>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<p>This is obviously very tedious to do by hand 😅. Here are some alternatives</p>
<ul>
<li>use <code>supersim --interop.autorelay</code> - this only works on supersim, but relayers for the testnet/prod environment will be available soon!</li>
<li><a href="guides/interop/relay-using-viem.html">use <code>viem</code> bindings/actions</a> - if you're using typescript, we have bindings available to make fetching identifiers and relaying messages easy.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/static/mermaid.min.js"></script>
        <script src="src/static/mermaid-init.js"></script>
        <script src="src/static/solidity.min.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
